{"ast":null,"code":"/* eslint-disable */\n// @ts-nocheck\nvar apo_idx, _final, first_part, first_part_i, folio_i, seqnum;\n\nvar unit_prefix = ['', '', 'གཉིས་', 'གསུམ་', 'བཞི་', 'ལྔ་', 'དྲུག་', 'བདུན་', 'བརྒྱད་', 'དགུ་'];\nvar unit_end = ['', 'གཅིག', 'གཉིས།', 'གསུམ།', 'བཞི།', 'ལྔ།', 'དྲུག', 'བདུན།', 'བརྒྱད།', 'དགུ།'];\nvar exceptions = {\n  0: 'ཐིག',\n  10: 'བཅུ།',\n  15: 'བཅོ་ལྔ།',\n  18: 'བཅོ་བརྒྱད།',\n  20: 'ཉི་ཤུ',\n  30: 'སུམ་བཅུ།'\n};\nvar dozens = ['', 'བཅུ་', 'ཉེར་', 'སོ་', 'ཞེ་', 'ང་', 'རེ་', 'དོན་', 'གྱ་', 'གོ་'];\nvar hundred_prefix = 'བརྒྱ་ ';\nvar hundred_end = 'བརྒྱ།';\nvar ten_end = 'བཅུ།';\n\nfunction intToTibStr(i, method) {\n  // returns the Tibetan representation of i in Tibetan letters\n  if (i < 0 && i > 999) {\n    return '';\n  }\n\n  var hundredsi = Math.floor(i / 100);\n  var resti = i % 100;\n  var hundredss = '';\n\n  if (hundredsi > 0) {\n    if (resti == 0) {\n      return unit_prefix[hundredsi] + hundred_end;\n    } else {\n      hundredss = unit_prefix[hundredsi] + hundred_prefix;\n    }\n  }\n\n  var rests;\n\n  if (exceptions[resti]) {\n    rests = exceptions[resti];\n  } else {\n    var dozensi = Math.floor(resti / 10);\n    var uniti = resti % 10;\n\n    if (uniti == 0) {\n      rests = unit_prefix[dozensi] + ten_end;\n    } else {\n      rests = dozens[dozensi] + unit_end[uniti];\n    }\n  }\n\n  return hundredss + rests;\n}\n\nvar folioRtest = RegExp(/^\\d+'*[ab]/);\nvar folioR = RegExp(/^(\\d+)('*)([ab])(.*)$/);\nexport var pagination_types = {\n  folios: {\n    // see https://github.com/buda-base/manifest-tk/blob/master/pagination-spec.md\n    is_well_formed: function is_well_formed(s) {\n      return folioRtest.test(s);\n    },\n    // 1a -> 1\n    // 1b -> 2\n    // 2a -> 3\n    // etc.\n    // this works only in the simple cases where there is no duplicate\n    // we cannot know anything about other cases, use with caution!\n    str_to_seqnum: function str_to_seqnum(s) {\n      var matchedS = folioR.exec(s);\n      if (!matchedS) return 0;\n      var first_part_i = parseInt(matchedS[1], 10);\n      return 2 * first_part_i + (matchedS[3] == 'b' ? 1 : 0);\n    },\n    // 1a -> 1b\n    // 1b -> 2a\n    // etc.\n    // this actually works in all cases, which is nice\n    next_str: function next_str(s) {\n      _final = s.substring(s.length - 1, s.length);\n      if (_final == 'a') return s.substring(0, s.length - 1) + 'b';\n      apo_idx = s.indexOf(\"'\");\n      if (apo_idx == -1) first_part = s.substring(0, s.length - 1);else first_part = s.substring(0, apo_idx);\n      return (parseInt(first_part, 10) + 1).toString() + 'a';\n    },\n    seqnum_to_str: function seqnum_to_str(i) {\n      _final = i % 2 == 1 ? 'b' : 'a';\n      return Math.floor(i / 2).toString() + _final;\n    },\n    seqnum_to_full_str: function seqnum_to_full_str(i) {\n      // no full page indication on verso... handle that at manifest template level\n      // if (i % 2 == 1) return '';\n      folio_i = Math.floor(i / 2);\n      return intToTibStr(folio_i);\n    },\n    compare: function compare(a, b) {\n      var matchedA = folioR.exec(a);\n      var matchedB = folioR.exec(b);\n      if (!matchedA || !matchedB) return 0;\n      var fnumA = parseInt(matchedA[1], 10);\n      var fnumB = parseInt(matchedB[1], 10);\n      if (fnumA != fnumB) return fnumA - fnumB;\n      var lenQuotA = matchedA[2].length;\n      var lenQuotB = matchedB[2].length;\n      if (lenQuotA != lenQuotB) return lenQuotA - lenQuotB;\n      if (matchedA[3] == 'a' && matchedB[3] == 'b') return -1;\n      if (matchedA[3] == 'b' && matchedB[3] == 'a') return 1;\n      return matchedA[4].localeCompare(matchedB[4]);\n    }\n  },\n  simple: {\n    is_well_formed: function is_well_formed(s) {\n      var i = parseInt(s, 10);\n      return !isNaN(i) && i > -1;\n    },\n    str_to_seqnum: function str_to_seqnum(s) {\n      return parseInt(s, 10);\n    },\n    next_str: function next_str(s) {\n      return (parseInt(s, 10) + 1).toString();\n    },\n    seqnum_to_str: function seqnum_to_str(i) {\n      return i.toString();\n    },\n    seqnum_to_full_str: function seqnum_to_full_str(i) {\n      // the page numbers are indicated in Latin numerals...\n      // maybe there are cases where they are indicated in\n      // Tibetan or Chinese numerals, we can see that later\n      return i.toString();\n    },\n    compare: function compare(a, b) {\n      return parseInt(a, 10) - parseInt(b, 10);\n    }\n  } // one boring TODO: roman numerals (preferably lower case)\n\n};\nexport function getPaginationTypes() {\n  return Object.keys(pagination_types);\n}\n\nfunction get_get_info(manifest, image) {\n  // TODO: in the future this could depend on the image as we would have multiple\n  // paginations per image\n  var manifest_pagination = manifest.pagination[0];\n\n  if (!image.pagination || !image.pagination[manifest_pagination.id]) {\n    // error\n    return null;\n  }\n\n  var image0_pagination = image.pagination[manifest_pagination.id];\n  var image0_section = image0_pagination.section;\n  var pgf = pagination_types[manifest_pagination.type];\n\n  if (!pgf.is_well_formed(image0_pagination.value)) {\n    // error\n    return null;\n  } // this is a bit tricky, but if we don't do that we end up with wrong\n  // value in edge cases where there are apostrophes and all that good stuff\n\n\n  var index1_pagination_value = pgf.next_str(image0_pagination.value);\n  var index1_seqnum = pgf.str_to_seqnum(index1_pagination_value); // then dealing with templates, which we don't always have\n\n  var template_odd = manifest.appData.bvmt['margin-indication-odd'];\n  var template_even = manifest.appData.bvmt['margin-indication-even'];\n  var lang = manifest.appData.bvmt['default-vol-string-lang'];\n  return function (nextimgseqnum) {\n    // nextimgseqnum is the index after the image we have given as index0.\n    // For instance is index0_pagination is '7a', if we want info about\n    // the next page, we call this function with argument 1.\n    if (nextimgseqnum < 1) {\n      // sorry, we can't compute that reliably\n      return null;\n    }\n\n    var seqnum,\n        pagination_val,\n        indication = null;\n\n    if (nextimgseqnum == 1) {\n      // 1 is a special case because of edge cases where index0 is 7'a for instance.\n      // Note that index1_seqnum might be wrong is some edge cases but\n      // it doesn't impact further computation so we let the user correct\n      // it if needed. On second thoughts, it would be wrong on verso, but\n      // the full_str on verso is empty so we should be safe in all cases.\n      pagination_val = index1_pagination_value;\n      seqnum = index1_seqnum;\n    } else {\n      // note that this seqnum has nothing to do with nextimgseqnum, it's the\n      // seqnum if everything was regular so it's sort of virtual. For 1a it would be\n      // 1, for 1b it would be 2, etc.\n      seqnum = nextimgseqnum + index1_seqnum - 1;\n      pagination_val = pgf.seqnum_to_str(seqnum);\n    }\n\n    var template = seqnum % 2 == 0 ? template_even : template_odd;\n\n    if (template !== undefined && template !== null) {\n      // we want to leave blank strings here\n      var indication_val = null;\n\n      if (template.includes('{pagenum:bo}')) {\n        var full_str = pgf.seqnum_to_full_str(seqnum);\n        indication_val = template.replace('{pagenum:bo}', full_str);\n      } else if (template.includes('{pagenum}')) {\n        indication_val = template.replace('{pagenum:bo}', seqnum);\n      }\n\n      if (indication_val !== null) {\n        indication = {\n          '@value': indication_val,\n          '@language': lang\n        };\n      }\n    }\n\n    var pagination = {\n      value: pagination_val\n    };\n\n    if (image0_section) {\n      pagination.section = image0_section;\n    }\n\n    return [pagination, indication];\n  };\n}\n\nexport default get_get_info; // a little example: we have a lit of images img01, img02, img03, etc.\n// the user validated that img02 is \"2'a\", and the used clicked on\n// \"update following unckecked items\" so for each following image\n// we want to have the new expected pagination and marginal indication\n// the first thing is to get the function:\n// var get_info = get_get_info('folios', \"2'a\")\n// console.log(\"we have img02 = 2'a\")\n// then if I want to get the info for img03 I do:\n// var img03info = get_info(1)\n// console.log('img03:')\n// console.log(img03info)\n// same for the next ones:\n// var img04info = get_info(2)\n// var img05info = get_info(3)\n// var compare = pagination_types.folios.compare;\n// console.log(compare(\"1b\", \"1a\"));\n// console.log(compare(\"1b\", \"1b\"));\n// console.log(compare(\"10b\", \"1b\"));\n// console.log(compare(\"1'a\", \"1b\"));","map":{"version":3,"sources":["/Users/aplchian/Documents/code/buda-next/utils/pagination-prediction.ts"],"names":["apo_idx","final","first_part","first_part_i","folio_i","seqnum","unit_prefix","unit_end","exceptions","dozens","hundred_prefix","hundred_end","ten_end","intToTibStr","i","method","hundredsi","Math","floor","resti","hundredss","rests","dozensi","uniti","folioRtest","RegExp","folioR","pagination_types","folios","is_well_formed","s","test","str_to_seqnum","matchedS","exec","parseInt","next_str","substring","length","indexOf","toString","seqnum_to_str","seqnum_to_full_str","compare","a","b","matchedA","matchedB","fnumA","fnumB","lenQuotA","lenQuotB","localeCompare","simple","isNaN","getPaginationTypes","Object","keys","get_get_info","manifest","image","manifest_pagination","pagination","id","image0_pagination","image0_section","section","pgf","type","value","index1_pagination_value","index1_seqnum","template_odd","appData","bvmt","template_even","lang","nextimgseqnum","pagination_val","indication","template","undefined","indication_val","includes","full_str","replace"],"mappings":"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","sourcesContent":["/* eslint-disable */\n// @ts-nocheck\nlet apo_idx, final, first_part, first_part_i, folio_i, seqnum\n\nvar unit_prefix = [\n    '',\n    '',\n    'གཉིས་',\n    'གསུམ་',\n    'བཞི་',\n    'ལྔ་',\n    'དྲུག་',\n    'བདུན་',\n    'བརྒྱད་',\n    'དགུ་',\n]\nvar unit_end = [\n    '',\n    'གཅིག',\n    'གཉིས།',\n    'གསུམ།',\n    'བཞི།',\n    'ལྔ།',\n    'དྲུག',\n    'བདུན།',\n    'བརྒྱད།',\n    'དགུ།',\n]\nvar exceptions = {\n    0: 'ཐིག',\n    10: 'བཅུ།',\n    15: 'བཅོ་ལྔ།',\n    18: 'བཅོ་བརྒྱད།',\n    20: 'ཉི་ཤུ',\n    30: 'སུམ་བཅུ།',\n}\nvar dozens = [\n    '',\n    'བཅུ་',\n    'ཉེར་',\n    'སོ་',\n    'ཞེ་',\n    'ང་',\n    'རེ་',\n    'དོན་',\n    'གྱ་',\n    'གོ་',\n]\nvar hundred_prefix = 'བརྒྱ་ '\nvar hundred_end = 'བརྒྱ།'\nvar ten_end = 'བཅུ།'\n\nfunction intToTibStr(i, method?) {\n    // returns the Tibetan representation of i in Tibetan letters\n    if (i < 0 && i > 999) {\n        return ''\n    }\n    var hundredsi = Math.floor(i / 100)\n    var resti = i % 100\n    var hundredss = ''\n    if (hundredsi > 0) {\n        if (resti == 0) {\n            return unit_prefix[hundredsi] + hundred_end\n        } else {\n            hundredss = unit_prefix[hundredsi] + hundred_prefix\n        }\n    }\n    var rests\n    if (exceptions[resti]) {\n        rests = exceptions[resti]\n    } else {\n        var dozensi = Math.floor(resti / 10)\n        var uniti = resti % 10\n        if (uniti == 0) {\n            rests = unit_prefix[dozensi] + ten_end\n        } else {\n            rests = dozens[dozensi] + unit_end[uniti]\n        }\n    }\n    return hundredss + rests\n}\n\nconst folioRtest = RegExp(/^\\d+'*[ab]/)\nconst folioR = RegExp(/^(\\d+)('*)([ab])(.*)$/)\n\nexport var pagination_types = {\n    folios: {\n        // see https://github.com/buda-base/manifest-tk/blob/master/pagination-spec.md\n        is_well_formed: function(s) {\n            return folioRtest.test(s)\n        },\n        // 1a -> 1\n        // 1b -> 2\n        // 2a -> 3\n        // etc.\n        // this works only in the simple cases where there is no duplicate\n        // we cannot know anything about other cases, use with caution!\n        str_to_seqnum: function(s) {\n            let matchedS = folioR.exec(s)\n            if (!matchedS) return 0\n            let first_part_i = parseInt(matchedS[1], 10)\n            return 2 * first_part_i + (matchedS[3] == 'b' ? 1 : 0)\n        },\n        // 1a -> 1b\n        // 1b -> 2a\n        // etc.\n        // this actually works in all cases, which is nice\n        next_str: function(s) {\n            final = s.substring(s.length - 1, s.length)\n            if (final == 'a') return s.substring(0, s.length - 1) + 'b'\n            apo_idx = s.indexOf(\"'\")\n            if (apo_idx == -1) first_part = s.substring(0, s.length - 1)\n            else first_part = s.substring(0, apo_idx)\n            return (parseInt(first_part, 10) + 1).toString() + 'a'\n        },\n        seqnum_to_str: function(i) {\n            final = i % 2 == 1 ? 'b' : 'a'\n            return Math.floor(i / 2).toString() + final\n        },\n        seqnum_to_full_str: function(i) {\n            // no full page indication on verso... handle that at manifest template level\n            // if (i % 2 == 1) return '';\n            folio_i = Math.floor(i / 2)\n            return intToTibStr(folio_i)\n        },\n        compare: function(a, b) {\n            let matchedA = folioR.exec(a)\n            let matchedB = folioR.exec(b)\n            if (!matchedA || !matchedB) return 0\n            let fnumA = parseInt(matchedA[1], 10)\n            let fnumB = parseInt(matchedB[1], 10)\n            if (fnumA != fnumB) return fnumA - fnumB\n            let lenQuotA = matchedA[2].length\n            let lenQuotB = matchedB[2].length\n            if (lenQuotA != lenQuotB) return lenQuotA - lenQuotB\n            if (matchedA[3] == 'a' && matchedB[3] == 'b') return -1\n            if (matchedA[3] == 'b' && matchedB[3] == 'a') return 1\n            return matchedA[4].localeCompare(matchedB[4])\n        },\n    },\n    simple: {\n        is_well_formed: function(s) {\n            let i = parseInt(s, 10)\n            return !isNaN(i) && i > -1\n        },\n        str_to_seqnum: function(s) {\n            return parseInt(s, 10)\n        },\n        next_str: function(s) {\n            return (parseInt(s, 10) + 1).toString()\n        },\n        seqnum_to_str: function(i) {\n            return i.toString()\n        },\n        seqnum_to_full_str: function(i) {\n            // the page numbers are indicated in Latin numerals...\n            // maybe there are cases where they are indicated in\n            // Tibetan or Chinese numerals, we can see that later\n            return i.toString()\n        },\n        compare: function(a, b) {\n            return parseInt(a, 10) - parseInt(b, 10)\n        },\n    },\n    // one boring TODO: roman numerals (preferably lower case)\n}\n\nexport function getPaginationTypes() {\n    return Object.keys(pagination_types)\n}\n\nfunction get_get_info(manifest, image) {\n    // TODO: in the future this could depend on the image as we would have multiple\n    // paginations per image\n    var manifest_pagination = manifest.pagination[0]\n    if (!image.pagination || !image.pagination[manifest_pagination.id]) {\n        // error\n        return null\n    }\n    var image0_pagination = image.pagination[manifest_pagination.id]\n    var image0_section = image0_pagination.section\n    var pgf = pagination_types[manifest_pagination.type]\n\n    if (!pgf.is_well_formed(image0_pagination.value)) {\n        // error\n        return null\n    }\n    // this is a bit tricky, but if we don't do that we end up with wrong\n    // value in edge cases where there are apostrophes and all that good stuff\n    var index1_pagination_value = pgf.next_str(image0_pagination.value)\n    var index1_seqnum = pgf.str_to_seqnum(index1_pagination_value)\n    // then dealing with templates, which we don't always have\n    var template_odd = manifest.appData.bvmt['margin-indication-odd']\n    var template_even = manifest.appData.bvmt['margin-indication-even']\n    var lang = manifest.appData.bvmt['default-vol-string-lang']\n    return function(nextimgseqnum) {\n        // nextimgseqnum is the index after the image we have given as index0.\n        // For instance is index0_pagination is '7a', if we want info about\n        // the next page, we call this function with argument 1.\n        if (nextimgseqnum < 1) {\n            // sorry, we can't compute that reliably\n            return null\n        }\n        var seqnum,\n            pagination_val,\n            indication = null\n        if (nextimgseqnum == 1) {\n            // 1 is a special case because of edge cases where index0 is 7'a for instance.\n            // Note that index1_seqnum might be wrong is some edge cases but\n            // it doesn't impact further computation so we let the user correct\n            // it if needed. On second thoughts, it would be wrong on verso, but\n            // the full_str on verso is empty so we should be safe in all cases.\n            pagination_val = index1_pagination_value\n            seqnum = index1_seqnum\n        } else {\n            // note that this seqnum has nothing to do with nextimgseqnum, it's the\n            // seqnum if everything was regular so it's sort of virtual. For 1a it would be\n            // 1, for 1b it would be 2, etc.\n            seqnum = nextimgseqnum + index1_seqnum - 1\n            pagination_val = pgf.seqnum_to_str(seqnum)\n        }\n        var template = seqnum % 2 == 0 ? template_even : template_odd\n        if (template !== undefined && template !== null) {\n            // we want to leave blank strings here\n            var indication_val = null\n            if (template.includes('{pagenum:bo}')) {\n                var full_str = pgf.seqnum_to_full_str(seqnum)\n                indication_val = template.replace('{pagenum:bo}', full_str)\n            } else if (template.includes('{pagenum}')) {\n                indication_val = template.replace('{pagenum:bo}', seqnum)\n            }\n            if (indication_val !== null) {\n                indication = { '@value': indication_val, '@language': lang }\n            }\n        }\n        var pagination: { value: string; section?: string } = {\n            value: pagination_val,\n        }\n        if (image0_section) {\n            pagination.section = image0_section\n        }\n        return [pagination, indication]\n    }\n}\n\nexport default get_get_info\n// a little example: we have a lit of images img01, img02, img03, etc.\n// the user validated that img02 is \"2'a\", and the used clicked on\n// \"update following unckecked items\" so for each following image\n// we want to have the new expected pagination and marginal indication\n// the first thing is to get the function:\n// var get_info = get_get_info('folios', \"2'a\")\n// console.log(\"we have img02 = 2'a\")\n// then if I want to get the info for img03 I do:\n// var img03info = get_info(1)\n// console.log('img03:')\n// console.log(img03info)\n// same for the next ones:\n// var img04info = get_info(2)\n// var img05info = get_info(3)\n// var compare = pagination_types.folios.compare;\n// console.log(compare(\"1b\", \"1a\"));\n// console.log(compare(\"1b\", \"1b\"));\n// console.log(compare(\"10b\", \"1b\"));\n// console.log(compare(\"1'a\", \"1b\"));\n"]},"metadata":{},"sourceType":"module"}